![캡처](https://user-images.githubusercontent.com/58182106/226663734-f1c15966-be00-4c87-b9b2-801d50e0588a.PNG)


* 알고리즘: 어떤 문제를 해결하기 위한 절차나 규칙의 집합 ex)버블 정렬
* 자료구조: 데이터를 저장하고 조직하는 방법, 효율적인 데이터 처리 및 검색을 위한 구조를 제공 ex) array
# bigO

* 빅오표기법: 코드의 성능을 얘기할때 정확한 전문용어를 사용하는것이 중요한데 알고리즘을 짤때 드는 시간을 말함.  

```
function addUpTo(n){//5n + 2, 2는   ,  O(n)
    let total = 0; //+1
    for(let i = 1 /*+1*/; i<=n; i++){  
        total = total + i;
    }
    return total;
}

function addUpto2(n){//3개 , O(1)
    return n * (n + 1) / 2 
}
```
```
let t1 = performance.now();//브라우저가 이 문서를 만든시간을 알려준다
console.log(addUpto2(1000000000))
let t2 = performance.now();
console.log(t2 - t1)
```
* 시간은 항상 연산의 갯수에 달려있음 ex) + - x

* 중첩 for문 O(n*n) = O(N^2)
* O(2n) == O(n)
* O(500) == O(1)
* O(5N^2) == O(N^2)
* => 작은 연산들은 중요하지 않다

* 공간복잡도: 사용되는 메모리에 주목,  ex) 배열에 push 한번씩 돌리면 O(n)
```
function addUpTo(n){
    let total = 0; //1
    for(let i = 1 /* 2 */; i<=n; i++){  
        total = total + i;
    }
    return total;
}
``` 
* 로그란: O(logn), 그래프로는 n^2의 반대느낌, O(nlogn): n^2 그래프느낌
* 빅오표기법 쓰면 좋은점
  1. 빅오를 통해 시간과 공간 복잡도에 대한이해를 높일 수 있음
  2. 빅오표기법은 세상 모든곳에서 사용
  3. 
# array
* 객체는 정렬되어 있을 필요가 없을때 잘작동한다
* 그리고 빠른접근, 입력과 제거를 원할때좋다
* 객체는 입력, 제거, 접근까지 모두상수, 탐색은 O(n)
* 객체는 정렬되어있지않다.

* 배열은 대부분 정렬되어 있는 데이터를 위해 사용
* 배열에 있는 데이터를 접근하는 것은 매우빠른 O(1)
* 배열 끝에 push(shift) 하면 O(1)
* 배열 앞에push(unshift(맨앞)), delete(shift(맨앞)) 하면 인덱스가 엉망이된다. => O(n)
* 

#
* splice가 있으면 O(n)
* 두개의 루프가 두개의 중첩된 개별 루프보다 훨씬 낫다
* 빈도수 세기 패턴: 중첩 for문 최대한 없이 하기
* 다중 포인터 패턴: 인덱스나 위치에 해당하는 포인터나 값을 만든 다음 특정 조건에 따라 중간지점에서부터 시작 지점이나 끝지점이나 양쪽지점을 향해 이동 시키는것
  * 포인터변수: 배열이나 문자열의 특정 위치를 가리키는것
* 고유값 세기 패턴: 
```
 i
[1,2,3,3,4,4,5,99] //arr[i] = arr[j] 면 i + 1
   j
```
* 슬라이딩윈도우 패턴: 앞뒤를 빼고 더해서 비교
* 분할정복: ex) 병합정렬, 퀵정렬 등등, 분할정복을 사용해서 시간을 절약가능

# 재귀
* 재귀: 자기자신을 호출하는 절차 -> 자기자신을 호출하는 함수
* 재귀는 모든곳에서 사용된다. json.parse가 보통 재귀적으로 작성된다
* json.parse: json을 객체로 변경
* stack overflow: 재귀가 멈추지 않는다는 의미
* slice(1): 배열에서 첫번째 요소를 제외한 나머지요소들을 포함하는 새로운 배열 반환
* concat: 배열 합치기
  

# 검색알고리즘
* indexOf(): 배열에서 지정된요소를 찾아 그인덱스를 반환
* 선형검색: 리스트나 배열에서 특정 값을 찾는데 사용되는 간단한 검색 알고리즘, 처음 부터 끝까지 순차적으로 각 요소를 비교하면 서 찾고자 하는 값을 찾는 방법, n
  * 리스트가 정렬되어있지 않거나 검색 대상이 리스트의 크기와 관계없이 간단한 검색을 할때 유용하다
* 이진검색: 정렬된 배열이나 리스트에서 특정 값을 찾는 알고리즘, 리스트의 중간요소와 찾고자 하는 값을 비교하여 찾고자 하는 값이 중간값보다 작은지 큰지를 판단하고 검색 범위를 반으로 줄여가는 방식, logn
  * 주로 정렬된 리스트에서 특정값을 찾아야 할때 사용
* naive string search: 문자열에서 특정 패턴을 찾는 간단한 알고리즘, 문자열을 처음부터 끝까지 순회하면서 패턴을 일치하는지 확인하는 방식으로 동작

# 정렬
* 기본적인 정렬 알고리즘: 버블정렬, 선택정렬, 삽입정렬, 이외에도 많다.
* 버블정렬: 인접한 두 원소를 비교하고 필요에 따라서 서로 위치를 교환하는 정렬 알고리즘,
  * 최선의 경우 n, 평균및 최악의 경우 n^2
  * 별로 효율적이이 않다. 
  * 흔히 사용되지 않음
* 선택정렬: 가장 작거나 큰 요소를 찾아서 리스트의 앞쪽으로 이동시키는 정렬 알고리즘
  * 입력 크기에 관계없이 항상 동일한 수의 비교와 교환을 수행해서 항상 n^2
  * 다른 정렬 알고리즘보다 효율성이 낮다
* 삽입정렬: 정렬되지 않은 부분의 원소를 하나씩 이미 정렬된 부분의 적절한 위치에 삽입하는 방식
  * 최선의 경우 n, 평균및 최악의 경우 n^2
* 기본 정렬의 단점: 데이터가 많아지면 오래걸린다
* 합병 정렬: 리스트를 한개가 될때까지 나누고 각각을 정렬하고 다시 합병하여 정렬된 리스트를 만드는 방식
  * n log n
  * 분할, 정렬, 합병 세가지 모두가 일어난다
  * 분할할때 log n 합병할때 n 이므로 nlogn 시간 복잡도를 가진다
* 퀵정렬: 분할 정복 알고리즘의 하나, 평균정으로 매우 효율적인 정렬 알고리즘
  * 한 원소를 기준으로 작은 요소들과 큰 요소들로 리스트를 분할하고 각각을 정렬하는 방식으로동작 -> 이과정을 재귀적으로 반복
  * 평균 nlogn 최악 n^2
  * 다른 정렬알고리즘보다 빠른 속도를 가지고 추가 메모리를 거의 사용하지 않으므로 공간 복잡도가 낮다
  * 분해 logn, 비교 n -> nlogn
  * 이미 정렬이 되어있는경우 오래걸린다
* 기수정렬: 비교정렬이 아닌 정렬 알고리즘, 정렬할 값의 자릿수를 이용해서 정렬하는 방식
  * 시간복잡도 d*(n+k), 
    * d: 가장큰 수의 자릿수
    * n: 리스트의 크기
    * k: 각자리수 별로 가능한 숫자의 개수
  * 정수 일때만 사용가능

# 자료구조
* 값 들의 모음, 데이터에 적용되는 값들 및 기능 혹은 작업들 사이의 관계를 포함 
* 개발자로서 많은 시간을 보낼수록 고급 자료구조 사용을 필요로 할 가능성이 그만큼 더 많아진다
* ex) gps 데이터와 위치 데이터를 표현할 수 있는 그래프를 이용해서 특정 지점들과 그래프 사이의 최단 경로를 찾는것은 단일 어레이로 지도를 표현하는것은 매우 어려운 작업 -> 연결 리스트가 매우 유용하게 사용 될 수 있다
* ex) 스케쥴러를 작성해야 할때 어떤 일의 우선순위가 가장 높은지 알아야한다 -> 이진 힙구조르 사용할 수도 있고 우선순위 큐와 이진힙구조가 적절
* 클래스: 사전에 정의된 속성 및 메소드 들을 이용해 객체를 생성하기 위한 청사진
* 자바스크립트에서의 클래스는 자바 스크립트에 이미 존재하는 프로토 타입 기반 상속자들을 구문적으로 눈속임 한것 -> 자바스크립트는 객체지향이 아님
* constructor: 클래스가 인스턴스화 될때 동작하는 특별한 함수

## 단일연결리스트
* array: 각 데이터 엘리먼트들은 위치가 지정되고 번호에 의해 인덱스(색인)가 부여된다.
* 단일연결리스트: 각 노드가 데이터 요소와 다음 노드를 가리키는 포인터(링크) 로 구성된 선형 데이터 구조, 각 노드는 데이터 요소와 다음 노드를 가리키는 포인터로 이루어져 있다
  * 삽입과 삭제가 상대적으로 간단하다
  * 검색(탐색)이 선형적으로 이루어진다. -> 특정 데이터를 찾기 위해서는 헤드부터 시작
  * 탐색 속도가 느리다
  * 역방향 탐색이 어렵다 -> 양방향 연결리스트
  * 추가 1, 삭제 1 or n, 찾기 n, 접근 n
* 단일 배열의 경우 0 위치에 무엇을 추가하려고 하면 모든 인덱스를 이동시켜줘야한다

## 이중연결리스트
* 각 노드가 데이터 요소와 이전 노드를 가리티는 포인터와 다음노드를 가리키는 포인터로 구성된 성형 데이터 구조
* 역방향 탐색가능
* 랜덤 액세스 가능
* 삽입, 삭제 연산이 보다 자유로움
* 단일연결리스트보다 많은 메모리 공간 사용 -> 포인터 조작하는 추가적인 오버헤드 발생가능
* 추가 1, 삭제 1 n, 찾기 n, 접근 n
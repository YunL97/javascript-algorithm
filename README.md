![캡처](https://user-images.githubusercontent.com/58182106/226663734-f1c15966-be00-4c87-b9b2-801d50e0588a.PNG)


* 알고리즘: 어떤 문제를 해결하기 위한 절차나 규칙의 집합 ex)버블 정렬
* 자료구조: 데이터를 저장하고 조직하는 방법, 효율적인 데이터 처리 및 검색을 위한 구조를 제공 ex) array
# bigO

* 빅오표기법: 코드의 성능을 얘기할때 정확한 전문용어를 사용하는것이 중요한데 알고리즘을 짤때 드는 시간을 말함.  

```
function addUpTo(n){//5n + 2, 2는   ,  O(n)
    let total = 0; //+1
    for(let i = 1 /*+1*/; i<=n; i++){  
        total = total + i;
    }
    return total;
}

function addUpto2(n){//3개 , O(1)
    return n * (n + 1) / 2 
}
```
```
let t1 = performance.now();//브라우저가 이 문서를 만든시간을 알려준다
console.log(addUpto2(1000000000))
let t2 = performance.now();
console.log(t2 - t1)
```
* 시간은 항상 연산의 갯수에 달려있음 ex) + - x

* 중첩 for문 O(n*n) = O(N^2)
* O(2n) == O(n)
* O(500) == O(1)
* O(5N^2) == O(N^2)
* => 작은 연산들은 중요하지 않다

* 공간복잡도: 사용되는 메모리에 주목,  ex) 배열에 push 한번씩 돌리면 O(n)
```
function addUpTo(n){
    let total = 0; //1
    for(let i = 1 /* 2 */; i<=n; i++){  
        total = total + i;
    }
    return total;
}
``` 
* 로그란: O(logn), 그래프로는 n^2의 반대느낌, O(nlogn): n^2 그래프느낌
* 빅오표기법 쓰면 좋은점
  1. 빅오를 통해 시간과 공간 복잡도에 대한이해를 높일 수 있음
  2. 빅오표기법은 세상 모든곳에서 사용
  3. 
# array
* 객체는 정렬되어 있을 필요가 없을때 잘작동한다
* 그리고 빠른접근, 입력과 제거를 원할때좋다
* 객체는 입력, 제거, 접근까지 모두상수, 탐색은 O(n)
* 객체는 정렬되어있지않다.

* 배열은 대부분 정렬되어 있는 데이터를 위해 사용
* 배열에 있는 데이터를 접근하는 것은 매우빠른 O(1)
* 배열 끝에 push(shift) 하면 O(1)
* 배열 앞에push(unshift(맨앞)), delete(shift(맨앞)) 하면 인덱스가 엉망이된다. => O(n)
* 

#
* splice가 있으면 O(n)
* 두개의 루프가 두개의 중첩된 개별 루프보다 훨씬 낫다
* 빈도수 세기 패턴: 중첩 for문 최대한 없이 하기
* 다중 포인터 패턴: 인덱스나 위치에 해당하는 포인터나 값을 만든 다음 특정 조건에 따라 중간지점에서부터 시작 지점이나 끝지점이나 양쪽지점을 향해 이동 시키는것
  * 포인터변수: 배열이나 문자열의 특정 위치를 가리키는것
* 고유값 세기 패턴: 
```
 i
[1,2,3,3,4,4,5,99] //arr[i] = arr[j] 면 i + 1
   j
```
* 슬라이딩윈도우 패턴: 앞뒤를 빼고 더해서 비교
* 분할정복: ex) 병합정렬, 퀵정렬 등등, 분할정복을 사용해서 시간을 절약가능

# 재귀
* 재귀: 자기자신을 호출하는 절차 -> 자기자신을 호출하는 함수
* 재귀는 모든곳에서 사용된다. json.parse가 보통 재귀적으로 작성된다
* json.parse: json을 객체로 변경
* stack overflow: 재귀가 멈추지 않는다는 의미
* slice(1): 배열에서 첫번째 요소를 제외한 나머지요소들을 포함하는 새로운 배열 반환
* concat: 배열 합치기
  

# 검색알고리즘
* indexOf(): 배열에서 지정된요소를 찾아 그인덱스를 반환
* 선형검색: 리스트나 배열에서 특정 값을 찾는데 사용되는 간단한 검색 알고리즘, 처음 부터 끝까지 순차적으로 각 요소를 비교하면 서 찾고자 하는 값을 찾는 방법, n
  * 리스트가 정렬되어있지 않거나 검색 대상이 리스트의 크기와 관계없이 간단한 검색을 할때 유용하다
* 이진검색: 정렬된 배열이나 리스트에서 특ㅈㅇ 값을 찾는 알고리즘, 리스트의 중간요소와 찾고자 하는 값을 비교하여 찾고자 하는 값이 중간값보다 작은지 큰지를 판단하고 검색 범위를 반으로 줄여가는 방식, logn
  * 주로 정렬된 리스트에서 특정값을 찾아야 할때 사용